# ãƒªãƒãƒ¼ã‚¹ãƒ†ãƒˆãƒªã‚¹ - å®Œå…¨å®Ÿè£…ä»•æ§˜æ›¸

## ç›®æ¬¡
1. [ã‚²ãƒ¼ãƒ æ¦‚è¦](#1-ã‚²ãƒ¼ãƒ æ¦‚è¦)
2. [é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—](#2-é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—)
3. [HTMLæ§‹é€ è¨­è¨ˆ](#3-htmlæ§‹é€ è¨­è¨ˆ)
4. [CSSè¨­è¨ˆä»•æ§˜](#4-cssè¨­è¨ˆä»•æ§˜)
5. [JavaScriptå®Ÿè£…æ‰‹é †](#5-javascriptå®Ÿè£…æ‰‹é †)
6. [å®Œå…¨ãªã‚³ãƒ¼ãƒ‰å®Ÿè£…](#6-å®Œå…¨ãªã‚³ãƒ¼ãƒ‰å®Ÿè£…)
7. [ãƒ†ã‚¹ãƒˆãƒ»ãƒ‡ãƒãƒƒã‚°æ‰‹é †](#7-ãƒ†ã‚¹ãƒˆãƒ‡ãƒãƒƒã‚°æ‰‹é †)
8. [ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ](#8-ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ)

---

## 1. ã‚²ãƒ¼ãƒ æ¦‚è¦

### 1.1 ã‚³ãƒ³ã‚»ãƒ—ãƒˆ
ãƒªãƒãƒ¼ã‚¹ãƒ†ãƒˆãƒªã‚¹ã¯ã€å¾“æ¥ã®ãƒ†ãƒˆãƒªã‚¹ã‚’é€†è»¢ã•ã›ãŸé©æ–°çš„ãªãƒ‘ã‚ºãƒ«ã‚²ãƒ¼ãƒ ã§ã™ã€‚ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯ãƒ†ãƒˆãƒªãƒŸãƒï¼ˆãƒŸãƒï¼‰ã‚’æ“ä½œã™ã‚‹ã®ã§ã¯ãªãã€AIãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã«é€ã‚Šè¾¼ã‚€ãƒŸãƒã‚’é¸æŠã—ã€AIã‚’å›°ã‚‰ã›ã¦ç”»é¢ä¸Šéƒ¨ã¾ã§ç©ã¿ä¸Šã’ã•ã›ã‚‹ã“ã¨ãŒç›®çš„ã§ã™ã€‚

### 1.2 åŸºæœ¬ãƒ«ãƒ¼ãƒ«
- ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã¯7ç¨®é¡ã®ãƒ†ãƒˆãƒªãƒŸãƒã‹ã‚‰é¸ã‚“ã§AIã«é€ä¿¡
- AIã¯å—ã‘å–ã£ãŸãƒŸãƒã‚’æœ€é©ã«é…ç½®ã—ã‚ˆã†ã¨ã™ã‚‹
- å®Œæˆã—ãŸãƒ©ã‚¤ãƒ³ã¯å³åº§ã«æ¶ˆå»ã•ã‚Œã‚‹
- ãƒŸãƒãŒç”»é¢ä¸Šéƒ¨3è¡Œä»¥å†…ã«åˆ°é”ã—ãŸã‚‰ãƒ—ãƒ¬ã‚¤ãƒ¤ãƒ¼ã®å‹åˆ©

### 1.3 ã‚²ãƒ¼ãƒ è¦ç´ 
- **ãƒœãƒ¼ãƒ‰**: 10Ã—20ã®ã‚°ãƒªãƒƒãƒ‰
- **ãƒ†ãƒˆãƒªãƒŸãƒ**: 7ç¨®é¡ï¼ˆIã€Oã€Tã€Sã€Zã€Jã€Lï¼‰
- **AI**: 3ã¤ã®é›£æ˜“åº¦ãƒ¬ãƒ™ãƒ«
- **ã‚¹ã‚³ã‚¢ã‚·ã‚¹ãƒ†ãƒ **: ãƒ”ãƒ¼ã‚¹é€ä¿¡ã¨ãƒ©ã‚¤ãƒ³æ¶ˆå»ã«ã‚ˆã‚‹ãƒã‚¤ãƒ³ãƒˆåˆ¶
- **ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³**: è½ä¸‹ã€ãƒ©ã‚¤ãƒ³æ¶ˆå»ã€ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢

---

## 2. é–‹ç™ºç’°å¢ƒã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—

### 2.1 å¿…è¦ãªæŠ€è¡“
- **HTML5**: æ§‹é€ ã¨CanvasAPI
- **CSS3**: ã‚¹ã‚¿ã‚¤ãƒªãƒ³ã‚°ã¨ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
- **JavaScript (ES6+)**: ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯ã¨åˆ¶å¾¡
- **Canvas API**: ã‚²ãƒ¼ãƒ æç”»

### 2.2 ãƒ•ã‚¡ã‚¤ãƒ«æ§‹æˆ
```
reverse-tetris/
â”œâ”€â”€ index.html          # ãƒ¡ã‚¤ãƒ³HTMLãƒ•ã‚¡ã‚¤ãƒ«
â”œâ”€â”€ styles.css          # CSSã‚¹ã‚¿ã‚¤ãƒ«
â”œâ”€â”€ game-engine.js      # ã‚²ãƒ¼ãƒ åˆ¶å¾¡ã‚¨ãƒ³ã‚¸ãƒ³
â”œâ”€â”€ ai-engine.js        # AIåˆ¶å¾¡ã‚¨ãƒ³ã‚¸ãƒ³
â”œâ”€â”€ main.js            # ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
â””â”€â”€ README.md          # ãƒ—ãƒ­ã‚¸ã‚§ã‚¯ãƒˆèª¬æ˜
```

### 2.3 é–‹ç™ºãƒ„ãƒ¼ãƒ«
- **ã‚¨ãƒ‡ã‚£ã‚¿**: VS Codeæ¨å¥¨
- **ãƒ–ãƒ©ã‚¦ã‚¶**: Chrome/Firefoxï¼ˆé–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ä½¿ç”¨ï¼‰
- **ãƒ­ãƒ¼ã‚«ãƒ«ã‚µãƒ¼ãƒãƒ¼**: Python HTTP Server / Live Server
- **ãƒãƒ¼ã‚¸ãƒ§ãƒ³ç®¡ç†**: Git

---

## 3. HTMLæ§‹é€ è¨­è¨ˆ

### 3.1 åŸºæœ¬æ§‹é€ 
```html
<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Reverse Tetris - å®Œå…¨ç‰ˆ</title>
    <link rel="stylesheet" href="styles.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>ğŸ® Reverse Tetris</h1>
            <p class="subtitle">AIã‚’ç©ã¿ä¸Šã’ã‚ï¼</p>
        </header>

        <div class="game-layout">
            <!-- å·¦ãƒ‘ãƒãƒ«: ã‚¹ã‚³ã‚¢ã¨çµ±è¨ˆ -->
            <aside class="left-panel">
                <div class="score-board">
                    <h2>ã‚¹ã‚³ã‚¢</h2>
                    <div class="score" id="score">0</div>
                </div>
                
                <div class="stats">
                    <div class="stat-item">
                        <span class="stat-label">é€ã£ãŸãƒŸãƒ:</span>
                        <span class="stat-value" id="pieces-sent">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">æ¶ˆå»ãƒ©ã‚¤ãƒ³:</span>
                        <span class="stat-value" id="lines-cleared">0</span>
                    </div>
                    <div class="stat-item">
                        <span class="stat-label">æœ€å¤§é«˜ã•:</span>
                        <span class="stat-value" id="max-height">0</span>
                    </div>
                </div>

                <div class="difficulty-selector">
                    <h3>é›£æ˜“åº¦</h3>
                    <select id="difficulty">
                        <option value="easy">ã‹ã‚“ãŸã‚“</option>
                        <option value="normal" selected>ãµã¤ã†</option>
                        <option value="hard">ã‚€ãšã‹ã—ã„</option>
                    </select>
                </div>
            </aside>

            <!-- ä¸­å¤®: ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ -->
            <main class="center-panel">
                <canvas id="game-board" width="300" height="600"></canvas>
                <div id="game-message" class="game-message hidden"></div>
            </main>

            <!-- å³ãƒ‘ãƒãƒ«: ãƒŸãƒé¸æŠ -->
            <aside class="right-panel">
                <div class="piece-selector-container">
                    <h3>ãƒŸãƒã‚’é¸æŠ</h3>
                    <div class="piece-selector" id="piece-selector"></div>
                </div>

                <div class="next-piece-display">
                    <h3>æ¬¡ã®ãƒŸãƒ</h3>
                    <canvas id="next-piece" width="120" height="80"></canvas>
                </div>

                <div class="controls">
                    <button id="start-btn" class="btn btn-primary">ã‚²ãƒ¼ãƒ é–‹å§‹</button>
                    <button id="pause-btn" class="btn btn-secondary" disabled>ä¸€æ™‚åœæ­¢</button>
                    <button id="reset-btn" class="btn btn-danger">ãƒªã‚»ãƒƒãƒˆ</button>
                </div>

                <div class="queue-indicator" id="queue-indicator">
                    ã‚­ãƒ¥ãƒ¼: <span id="queue-count">0</span>
                </div>
            </aside>
        </div>
    </div>

    <script src="game-engine.js"></script>
    <script src="ai-engine.js"></script>
    <script src="main.js"></script>
</body>
</html>
```

### 3.2 HTMLè¦ç´ ã®å½¹å‰²

#### 3.2.1 ã‚³ãƒ³ãƒ†ãƒŠæ§‹é€ 
- `container`: å…¨ä½“ã‚’ãƒ©ãƒƒãƒ—ã™ã‚‹æœ€ä¸Šä½è¦ç´ 
- `game-layout`: 3ãƒ‘ãƒãƒ«ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆã®ãƒ•ãƒ¬ãƒƒã‚¯ã‚¹ã‚³ãƒ³ãƒ†ãƒŠ
- `left-panel`, `center-panel`, `right-panel`: æ©Ÿèƒ½åˆ¥ãƒ‘ãƒãƒ«

#### 3.2.2 ã‚²ãƒ¼ãƒ è¡¨ç¤ºè¦ç´ 
- `game-board`: ãƒ¡ã‚¤ãƒ³ã‚²ãƒ¼ãƒ æç”»ç”¨Canvasï¼ˆ300Ã—600pxï¼‰
- `next-piece`: æ¬¡ã®ãƒ”ãƒ¼ã‚¹è¡¨ç¤ºç”¨Canvasï¼ˆ120Ã—80pxï¼‰
- `game-message`: ã‚²ãƒ¼ãƒ çŠ¶æ…‹ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤ºã‚¨ãƒªã‚¢

#### 3.2.3 UIåˆ¶å¾¡è¦ç´ 
- `piece-selector`: ãƒ”ãƒ¼ã‚¹é¸æŠãƒœã‚¿ãƒ³ã®å‹•çš„ç”Ÿæˆã‚¨ãƒªã‚¢
- `difficulty`: AIé›£æ˜“åº¦é¸æŠã‚»ãƒ¬ã‚¯ãƒˆãƒœãƒƒã‚¯ã‚¹
- `start-btn`, `pause-btn`, `reset-btn`: ã‚²ãƒ¼ãƒ åˆ¶å¾¡ãƒœã‚¿ãƒ³

#### 3.2.4 æƒ…å ±è¡¨ç¤ºè¦ç´ 
- `score`: ç¾åœ¨ã®ã‚¹ã‚³ã‚¢è¡¨ç¤º
- `pieces-sent`: é€ä¿¡ã—ãŸãƒ”ãƒ¼ã‚¹æ•°
- `lines-cleared`: æ¶ˆå»ã—ãŸãƒ©ã‚¤ãƒ³æ•°
- `max-height`: ç¾åœ¨ã®æœ€å¤§é«˜ã•
- `queue-count`: å¾…æ©Ÿä¸­ã®ãƒ”ãƒ¼ã‚¹æ•°

---

## 4. CSSè¨­è¨ˆä»•æ§˜

### 4.1 åŸºæœ¬ã‚¹ã‚¿ã‚¤ãƒ«è¨­è¨ˆ

```css
/* åŸºæœ¬è¨­å®šã¨ãƒªã‚»ãƒƒãƒˆ */
* {
    box-sizing: border-box;
    margin: 0;
    padding: 0;
}

body {
    font-family: 'Arial', sans-serif;
    background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
    color: #ffffff;
    min-height: 100vh;
    overflow-x: auto;
}

.container {
    max-width: 1200px;
    margin: 0 auto;
    padding: 20px;
}

/* ãƒ˜ãƒƒãƒ€ãƒ¼ */
header {
    text-align: center;
    margin-bottom: 30px;
}

header h1 {
    font-size: 2.5rem;
    margin-bottom: 10px;
    text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
}

.subtitle {
    font-size: 1.2rem;
    color: #b0b0b0;
}
```

### 4.2 ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆè¨­è¨ˆ

```css
/* ãƒ¡ã‚¤ãƒ³ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ */
.game-layout {
    display: flex;
    gap: 30px;
    justify-content: center;
    align-items: flex-start;
    flex-wrap: wrap;
}

.left-panel,
.right-panel {
    width: 250px;
    min-width: 200px;
}

.center-panel {
    position: relative;
    display: flex;
    flex-direction: column;
    align-items: center;
}

/* ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œ */
@media (max-width: 768px) {
    .game-layout {
        flex-direction: column;
        align-items: center;
    }
    
    .left-panel,
    .right-panel {
        width: 100%;
        max-width: 400px;
    }
}
```

### 4.3 ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰

```css
/* ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰ */
#game-board {
    border: 3px solid #4a90e2;
    border-radius: 8px;
    background: #000;
    box-shadow: 0 0 20px rgba(74, 144, 226, 0.3);
}

.game-message {
    position: absolute;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    background: rgba(0, 0, 0, 0.9);
    padding: 30px;
    border-radius: 15px;
    text-align: center;
    box-shadow: 0 0 30px rgba(0, 0, 0, 0.8);
    z-index: 10;
}

.game-message.hidden {
    display: none;
}

.game-message h2 {
    font-size: 2rem;
    margin-bottom: 15px;
    color: #4a90e2;
}
```

### 4.4 UIè¦ç´ 

```css
/* ã‚¹ã‚³ã‚¢ãƒœãƒ¼ãƒ‰ */
.score-board {
    background: rgba(255, 255, 255, 0.1);
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 20px;
    backdrop-filter: blur(10px);
}

.score-board h2 {
    text-align: center;
    margin-bottom: 10px;
    color: #4a90e2;
}

.score {
    font-size: 2rem;
    font-weight: bold;
    text-align: center;
    color: #ffeb3b;
}

/* çµ±è¨ˆæƒ…å ± */
.stats {
    background: rgba(255, 255, 255, 0.1);
    padding: 15px;
    border-radius: 10px;
    margin-bottom: 20px;
}

.stat-item {
    display: flex;
    justify-content: space-between;
    margin-bottom: 8px;
}

.stat-label {
    color: #b0b0b0;
}

.stat-value {
    font-weight: bold;
    color: #ffffff;
}

/* ãƒ”ãƒ¼ã‚¹é¸æŠ */
.piece-selector-container {
    background: rgba(255, 255, 255, 0.1);
    padding: 20px;
    border-radius: 10px;
    margin-bottom: 20px;
}

.piece-selector {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 10px;
    margin-top: 15px;
}

.piece-btn {
    width: 50px;
    height: 50px;
    border: 2px solid #4a90e2;
    background: rgba(74, 144, 226, 0.2);
    border-radius: 8px;
    cursor: pointer;
    transition: all 0.2s ease;
    display: flex;
    align-items: center;
    justify-content: center;
}

.piece-btn:hover {
    background: rgba(74, 144, 226, 0.4);
    transform: scale(1.05);
}

.piece-btn.selected {
    background: rgba(255, 235, 59, 0.6);
    border-color: #ffeb3b;
    transform: scale(1.1);
}

/* ãƒœã‚¿ãƒ³ */
.btn {
    padding: 12px 24px;
    border: none;
    border-radius: 6px;
    font-size: 1rem;
    font-weight: bold;
    cursor: pointer;
    transition: all 0.2s ease;
    margin: 5px;
}

.btn-primary {
    background: #4a90e2;
    color: white;
}

.btn-primary:hover:not(:disabled) {
    background: #357abd;
}

.btn-secondary {
    background: #6c757d;
    color: white;
}

.btn-secondary:hover:not(:disabled) {
    background: #545b62;
}

.btn-danger {
    background: #dc3545;
    color: white;
}

.btn-danger:hover:not(:disabled) {
    background: #c82333;
}

.btn:disabled {
    opacity: 0.6;
    cursor: not-allowed;
}

/* æ¬¡ã®ãƒ”ãƒ¼ã‚¹è¡¨ç¤º */
.next-piece-display {
    background: rgba(255, 255, 255, 0.1);
    padding: 15px;
    border-radius: 10px;
    margin-bottom: 20px;
    text-align: center;
}

#next-piece {
    border: 1px solid #4a90e2;
    border-radius: 4px;
    background: #000;
    margin-top: 10px;
}

/* é›£æ˜“åº¦é¸æŠ */
.difficulty-selector {
    background: rgba(255, 255, 255, 0.1);
    padding: 15px;
    border-radius: 10px;
    margin-bottom: 20px;
}

.difficulty-selector h3 {
    margin-bottom: 10px;
    color: #4a90e2;
}

.difficulty-selector select {
    width: 100%;
    padding: 8px;
    border: 1px solid #4a90e2;
    border-radius: 4px;
    background: rgba(0, 0, 0, 0.5);
    color: white;
    font-size: 1rem;
}

/* ã‚­ãƒ¥ãƒ¼ã‚¤ãƒ³ã‚¸ã‚±ãƒ¼ã‚¿ãƒ¼ */
.queue-indicator {
    background: rgba(255, 255, 255, 0.1);
    padding: 10px;
    border-radius: 10px;
    text-align: center;
    font-size: 0.9rem;
}

#queue-count {
    font-weight: bold;
    color: #ffeb3b;
}
```

### 4.5 ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

```css
/* ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³ */
@keyframes pulse {
    0% { transform: scale(1); }
    50% { transform: scale(1.05); }
    100% { transform: scale(1); }
}

@keyframes fadeIn {
    from { opacity: 0; transform: translateY(-20px); }
    to { opacity: 1; transform: translateY(0); }
}

@keyframes slideIn {
    from { transform: translateX(-100%); }
    to { transform: translateX(0); }
}

.pulse {
    animation: pulse 0.3s ease-in-out;
}

.fade-in {
    animation: fadeIn 0.5s ease-out;
}

.slide-in {
    animation: slideIn 0.3s ease-out;
}
```

---

## 5. JavaScriptå®Ÿè£…æ‰‹é †

### 5.1 æ®µéšçš„å®Ÿè£…ãƒ—ãƒ©ãƒ³

#### ãƒ•ã‚§ãƒ¼ã‚º1: åŸºæœ¬æ§‹é€ ã¨ãƒ‡ãƒ¼ã‚¿è¨­è¨ˆ
1. ãƒ†ãƒˆãƒªãƒŸãƒå®šç¾©ã¨ã‚²ãƒ¼ãƒ å®šæ•°
2. ã‚²ãƒ¼ãƒ çŠ¶æ…‹ç®¡ç†ã‚¯ãƒ©ã‚¹
3. ãƒœãƒ¼ãƒ‰ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

#### ãƒ•ã‚§ãƒ¼ã‚º2: æç”»ã‚¨ãƒ³ã‚¸ãƒ³
1. CanvasåˆæœŸåŒ–ã¨åŸºæœ¬æç”»
2. ã‚°ãƒªãƒƒãƒ‰æç”»
3. ãƒ†ãƒˆãƒªãƒŸãƒæç”»

#### ãƒ•ã‚§ãƒ¼ã‚º3: ã‚²ãƒ¼ãƒ ãƒ­ã‚¸ãƒƒã‚¯
1. ãƒ”ãƒ¼ã‚¹é…ç½®ã‚·ã‚¹ãƒ†ãƒ 
2. ãƒ©ã‚¤ãƒ³æ¶ˆå»å‡¦ç†
3. ã‚²ãƒ¼ãƒ çŠ¶æ…‹ãƒã‚§ãƒƒã‚¯

#### ãƒ•ã‚§ãƒ¼ã‚º4: AIã‚¨ãƒ³ã‚¸ãƒ³
1. AIè©•ä¾¡é–¢æ•°
2. é…ç½®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
3. é›£æ˜“åº¦èª¿æ•´

#### ãƒ•ã‚§ãƒ¼ã‚º5: UIçµ±åˆ
1. ã‚¤ãƒ™ãƒ³ãƒˆãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
2. ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³
3. ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¤ãƒ³ã‚¿ãƒ¼ãƒ•ã‚§ãƒ¼ã‚¹

### 5.2 å®Ÿè£…æ‰‹é †è©³ç´°

#### ã‚¹ãƒ†ãƒƒãƒ—1: åŸºæœ¬å®šæ•°ã¨ãƒ†ãƒˆãƒªãƒŸãƒå®šç¾©

```javascript
// ãƒ†ãƒˆãƒªãƒŸãƒå®šç¾©
const TETROMINOS = {
    I: { 
        shape: [[1,1,1,1]], 
        color: '#60a5fa',
        name: 'I'
    },
    O: { 
        shape: [[1,1],[1,1]], 
        color: '#fbbf24',
        name: 'O'
    },
    T: { 
        shape: [[0,1,0],[1,1,1]], 
        color: '#c084fc',
        name: 'T'
    },
    S: { 
        shape: [[0,1,1],[1,1,0]], 
        color: '#34d399',
        name: 'S'
    },
    Z: { 
        shape: [[1,1,0],[0,1,1]], 
        color: '#f87171',
        name: 'Z'
    },
    J: { 
        shape: [[1,0,0],[1,1,1]], 
        color: '#38bdf8',
        name: 'J'
    },
    L: { 
        shape: [[0,0,1],[1,1,1]], 
        color: '#fb923c',
        name: 'L'
    }
};

// ã‚²ãƒ¼ãƒ å®šæ•°
const GRID_WIDTH = 10;
const GRID_HEIGHT = 20;
const CELL_SIZE = 30;
const DROP_SPEED = 20;
const LINE_CLEAR_DELAY = 400;
const HIGHLIGHT_DURATION = 300;
```

#### ã‚¹ãƒ†ãƒƒãƒ—2: ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã‚¯ãƒ©ã‚¹ã®éª¨æ ¼

```javascript
class GameEngine {
    constructor() {
        // Canvasè¦ç´ ã®å–å¾—
        this.canvas = document.getElementById('game-board');
        this.ctx = this.canvas.getContext('2d');
        this.nextCanvas = document.getElementById('next-piece');
        this.nextCtx = this.nextCanvas.getContext('2d');
        
        // ã‚²ãƒ¼ãƒ çŠ¶æ…‹
        this.state = {
            isPlaying: false,
            isPaused: false,
            isGameClear: false,
            isProcessing: false
        };
        
        // ã‚²ãƒ¼ãƒ ãƒ‡ãƒ¼ã‚¿
        this.grid = this.createEmptyGrid();
        this.score = 400;
        this.piecesSent = 0;
        this.linesCleared = 0;
        this.currentPiece = null;
        this.selectedPiece = null;
        this.highlightedLines = [];
        
        // ã‚­ãƒ¥ãƒ¼ç®¡ç†
        this.pieceQueue = [];
        this.maxQueueSize = 5;
        
        // é›£æ˜“åº¦
        this.difficulty = 'normal';
        
        this.init();
    }
    
    init() {
        this.setupCanvas();
        this.draw();
        console.log('GameEngine initialized');
    }
    
    // ä»¥ä¸‹ã€å„ãƒ¡ã‚½ãƒƒãƒ‰ã‚’æ®µéšçš„ã«å®Ÿè£…
}
```

#### ã‚¹ãƒ†ãƒƒãƒ—3: Canvasæç”»ã‚·ã‚¹ãƒ†ãƒ 

```javascript
// Canvasè¨­å®šãƒ¡ã‚½ãƒƒãƒ‰
setupCanvas() {
    this.canvas.width = GRID_WIDTH * CELL_SIZE;
    this.canvas.height = GRID_HEIGHT * CELL_SIZE;
    this.ctx.imageSmoothingEnabled = false;
}

// ãƒ¡ã‚¤ãƒ³æç”»ãƒ¡ã‚½ãƒƒãƒ‰
draw() {
    // èƒŒæ™¯ã‚¯ãƒªã‚¢
    this.ctx.fillStyle = '#111';
    this.ctx.fillRect(0, 0, this.canvas.width, this.canvas.height);
    
    // ã‚°ãƒªãƒƒãƒ‰ç·šæç”»
    this.drawGrid();
    
    // ãƒœãƒ¼ãƒ‰ä¸Šã®ãƒ–ãƒ­ãƒƒã‚¯æç”»
    this.drawBlocks();
    
    // ãƒã‚¤ãƒ©ã‚¤ãƒˆã•ã‚ŒãŸãƒ©ã‚¤ãƒ³æç”»
    this.drawHighlightedLines();
    
    // è½ä¸‹ä¸­ã®ãƒ”ãƒ¼ã‚¹æç”»
    this.drawCurrentPiece();
}

// ã‚°ãƒªãƒƒãƒ‰ç·šæç”»
drawGrid() {
    this.ctx.strokeStyle = '#333';
    this.ctx.lineWidth = 0.5;
    
    // ç¸¦ç·š
    for (let x = 0; x <= GRID_WIDTH; x++) {
        this.ctx.beginPath();
        this.ctx.moveTo(x * CELL_SIZE, 0);
        this.ctx.lineTo(x * CELL_SIZE, this.canvas.height);
        this.ctx.stroke();
    }
    
    // æ¨ªç·š
    for (let y = 0; y <= GRID_HEIGHT; y++) {
        this.ctx.beginPath();
        this.ctx.moveTo(0, y * CELL_SIZE);
        this.ctx.lineTo(this.canvas.width, y * CELL_SIZE);
        this.ctx.stroke();
    }
}
```

---

## 6. å®Œå…¨ãªã‚³ãƒ¼ãƒ‰å®Ÿè£…

ã“ã®ç« ã§ã¯ã€å„ãƒ•ã‚¡ã‚¤ãƒ«ã®å®Œå…¨ãªã‚³ãƒ¼ãƒ‰ã‚’æä¾›ã—ã¾ã™ã€‚

### 6.1 game-engine.jsï¼ˆå®Œå…¨ç‰ˆï¼‰

[å‰å›ä¿®æ­£æ¸ˆã¿ã®ã‚³ãƒ¼ãƒ‰ã‚’ãƒ™ãƒ¼ã‚¹ã«ã€ã‚³ãƒ¡ãƒ³ãƒˆã¨è©³ç´°èª¬æ˜ã‚’è¿½åŠ ã—ãŸå®Œå…¨ç‰ˆã‚’è¨˜è¼‰]

### 6.2 ai-engine.jsï¼ˆå®Œå…¨ç‰ˆï¼‰

```javascript
/**
 * AIã‚¨ãƒ³ã‚¸ãƒ³ - ãƒªãƒãƒ¼ã‚¹ãƒ†ãƒˆãƒªã‚¹
 * ãƒ†ãƒˆãƒªãƒŸãƒã®æœ€é©é…ç½®ã‚’è¨ˆç®—ã™ã‚‹AIã‚·ã‚¹ãƒ†ãƒ 
 */

class AIEngine {
    constructor() {
        // AIè©•ä¾¡ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ï¼ˆé›£æ˜“åº¦åˆ¥ï¼‰
        this.parameters = {
            easy: {
                heightWeight: -0.3,
                linesWeight: 0.5,
                holesWeight: -0.5,
                bumpinessWeight: -0.2,
                randomness: 0.3
            },
            normal: {
                heightWeight: -0.5,
                linesWeight: 1.0,
                holesWeight: -1.0,
                bumpinessWeight: -0.3,
                randomness: 0.1
            },
            hard: {
                heightWeight: -0.8,
                linesWeight: 1.5,
                holesWeight: -2.0,
                bumpinessWeight: -0.5,
                randomness: 0.0
            }
        };
    }
    
    /**
     * æœ€é©ãªé…ç½®ã‚’è¦‹ã¤ã‘ã‚‹
     * @param {Array} grid - ç¾åœ¨ã®ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰
     * @param {Array} shape - ãƒ†ãƒˆãƒªãƒŸãƒã®å½¢çŠ¶
     * @param {string} difficulty - é›£æ˜“åº¦
     * @returns {Object} æœ€é©é…ç½®æƒ…å ±
     */
    findBestPlacement(grid, shape, difficulty = 'normal') {
        const params = this.parameters[difficulty];
        let bestPlacement = null;
        let bestScore = -Infinity;
        
        // å…¨ã¦ã®å¯èƒ½ãªé…ç½®ã‚’è©•ä¾¡
        const rotations = this.getAllRotations(shape);
        
        for (let rotation = 0; rotation < rotations.length; rotation++) {
            const rotatedShape = rotations[rotation];
            
            for (let x = 0; x <= GRID_WIDTH - rotatedShape[0].length; x++) {
                const y = this.findDropPosition(grid, rotatedShape, x);
                
                if (y >= 0) {
                    // ä»®é…ç½®ã—ã¦ãƒœãƒ¼ãƒ‰ã‚’è©•ä¾¡
                    const testGrid = this.simulatePlacement(grid, rotatedShape, x, y);
                    const score = this.evaluateBoard(testGrid, params);
                    
                    if (score > bestScore) {
                        bestScore = score;
                        bestPlacement = {
                            x: x,
                            y: y,
                            rotation: rotation,
                            shape: rotatedShape,
                            score: score
                        };
                    }
                }
            }
        }
        
        // ãƒ©ãƒ³ãƒ€ãƒ æ€§ã‚’è¿½åŠ ï¼ˆé›£æ˜“åº¦ã«ã‚ˆã‚‹èª¿æ•´ï¼‰
        if (params.randomness > 0 && Math.random() < params.randomness) {
            return this.getRandomPlacement(grid, shape);
        }
        
        return bestPlacement;
    }
    
    /**
     * ãƒ†ãƒˆãƒªãƒŸãƒã®å…¨å›è»¢çŠ¶æ…‹ã‚’å–å¾—
     * @param {Array} shape - åŸºæœ¬å½¢çŠ¶
     * @returns {Array} å›è»¢çŠ¶æ…‹ã®é…åˆ—
     */
    getAllRotations(shape) {
        const rotations = [shape];
        let current = shape;
        
        for (let i = 0; i < 3; i++) {
            current = this.rotateShape(current);
            // é‡è¤‡ãƒã‚§ãƒƒã‚¯
            if (!this.shapeEquals(current, rotations[0])) {
                rotations.push(current);
            } else {
                break;
            }
        }
        
        return rotations;
    }
    
    /**
     * å½¢çŠ¶ã‚’90åº¦å›è»¢
     * @param {Array} shape - å›è»¢ã™ã‚‹å½¢çŠ¶
     * @returns {Array} å›è»¢å¾Œã®å½¢çŠ¶
     */
    rotateShape(shape) {
        const rows = shape.length;
        const cols = shape[0].length;
        const rotated = Array(cols).fill().map(() => Array(rows).fill(0));
        
        for (let i = 0; i < rows; i++) {
            for (let j = 0; j < cols; j++) {
                rotated[j][rows - 1 - i] = shape[i][j];
            }
        }
        
        return rotated;
    }
    
    /**
     * å½¢çŠ¶ã®ç­‰ä¾¡æ€§ãƒã‚§ãƒƒã‚¯
     * @param {Array} shape1 - å½¢çŠ¶1
     * @param {Array} shape2 - å½¢çŠ¶2
     * @returns {boolean} ç­‰ã—ã„ã‹ã©ã†ã‹
     */
    shapeEquals(shape1, shape2) {
        if (shape1.length !== shape2.length) return false;
        
        for (let i = 0; i < shape1.length; i++) {
            if (shape1[i].length !== shape2[i].length) return false;
            for (let j = 0; j < shape1[i].length; j++) {
                if (shape1[i][j] !== shape2[i][j]) return false;
            }
        }
        
        return true;
    }
    
    /**
     * è½ä¸‹ä½ç½®ã‚’è¨ˆç®—
     * @param {Array} grid - ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰
     * @param {Array} shape - ãƒ†ãƒˆãƒªãƒŸãƒå½¢çŠ¶
     * @param {number} x - Xåº§æ¨™
     * @returns {number} Yåº§æ¨™
     */
    findDropPosition(grid, shape, x) {
        for (let y = 0; y <= GRID_HEIGHT - shape.length; y++) {
            if (!this.canPlacePiece(grid, shape, x, y)) {
                return Math.max(0, y - 1);
            }
        }
        return GRID_HEIGHT - shape.length;
    }
    
    /**
     * ãƒ”ãƒ¼ã‚¹é…ç½®å¯èƒ½æ€§ãƒã‚§ãƒƒã‚¯
     * @param {Array} grid - ã‚²ãƒ¼ãƒ ãƒœãƒ¼ãƒ‰
     * @param {Array} shape - ãƒ†ãƒˆãƒªãƒŸãƒå½¢çŠ¶
     * @param {number} x - Xåº§æ¨™
     * @param {number} y - Yåº§æ¨™
     * @returns {boolean} é…ç½®å¯èƒ½ã‹ã©ã†ã‹
     */
    canPlacePiece(grid, shape, x, y) {
        for (let dy = 0; dy < shape.length; dy++) {
            for (let dx = 0; dx < shape[dy].length; dx++) {
                if (shape[dy][dx]) {
                    const boardX = x + dx;
                    const boardY = y + dy;
                    
                    if (boardX < 0 || boardX >= GRID_WIDTH || boardY >= GRID_HEIGHT) {
                        return false;
                    }
                    
                    if (boardY >= 0 && grid[boardY][boardX]) {
                        return false;
                    }
                }
            }
        }
        return true;
    }
    
    /**
     * é…ç½®ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³
     * @param {Array} grid - å…ƒã®ã‚°ãƒªãƒƒãƒ‰
     * @param {Array} shape - ãƒ†ãƒˆãƒªãƒŸãƒå½¢çŠ¶
     * @param {number} x - Xåº§æ¨™
     * @param {number} y - Yåº§æ¨™
     * @returns {Array} ã‚·ãƒŸãƒ¥ãƒ¬ãƒ¼ã‚·ãƒ§ãƒ³å¾Œã®ã‚°ãƒªãƒƒãƒ‰
     */
    simulatePlacement(grid, shape, x, y) {
        // ã‚°ãƒªãƒƒãƒ‰ã®ãƒ‡ã‚£ãƒ¼ãƒ—ã‚³ãƒ”ãƒ¼
        const testGrid = grid.map(row => [...row]);
        
        // ãƒ”ãƒ¼ã‚¹ã‚’é…ç½®
        for (let dy = 0; dy < shape.length; dy++) {
            for (let dx = 0; dx < shape[dy].length; dx++) {
                if (shape[dy][dx]) {
                    const boardX = x + dx;
                    const boardY = y + dy;
                    
                    if (boardY >= 0 && boardY < GRID_HEIGHT && 
                        boardX >= 0 && boardX < GRID_WIDTH) {
                        testGrid[boardY][boardX] = 1; // 1ã§å æœ‰ã‚’è¡¨ç¾
                    }
                }
            }
        }
        
        // å®Œæˆãƒ©ã‚¤ãƒ³ã‚’æ¶ˆå»
        return this.clearCompletedLines(testGrid);
    }
    
    /**
     * å®Œæˆãƒ©ã‚¤ãƒ³ã‚’æ¶ˆå»
     * @param {Array} grid - ã‚°ãƒªãƒƒãƒ‰
     * @returns {Array} æ¶ˆå»å¾Œã®ã‚°ãƒªãƒƒãƒ‰
     */
    clearCompletedLines(grid) {
        const newGrid = [];
        let linesCleared = 0;
        
        for (let y = 0; y < GRID_HEIGHT; y++) {
            let isComplete = true;
            for (let x = 0; x < GRID_WIDTH; x++) {
                if (grid[y][x] === 0) {
                    isComplete = false;
                    break;
                }
            }
            
            if (!isComplete) {
                newGrid.push([...grid[y]]);
            } else {
                linesCleared++;
            }
        }
        
        // ä¸Šéƒ¨ã«ç©ºè¡Œã‚’è¿½åŠ 
        while (newGrid.length < GRID_HEIGHT) {
            newGrid.unshift(Array(GRID_WIDTH).fill(0));
        }
        
        return newGrid;
    }
    
    /**
     * ãƒœãƒ¼ãƒ‰è©•ä¾¡é–¢æ•°
     * @param {Array} grid - è©•ä¾¡ã™ã‚‹ã‚°ãƒªãƒƒãƒ‰
     * @param {Object} params - è©•ä¾¡ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿
     * @returns {number} è©•ä¾¡ã‚¹ã‚³ã‚¢
     */
    evaluateBoard(grid, params) {
        const height = this.calculateHeight(grid);
        const lines = this.countCompletedLines(grid);
        const holes = this.countHoles(grid);
        const bumpiness = this.calculateBumpiness(grid);
        
        return (
            height * params.heightWeight +
            lines * params.linesWeight +
            holes * params.holesWeight +
            bumpiness * params.bumpinessWeight
        );
    }
    
    /**
     * æœ€å¤§é«˜ã•ã‚’è¨ˆç®—
     * @param {Array} grid - ã‚°ãƒªãƒƒãƒ‰
     * @returns {number} æœ€å¤§é«˜ã•
     */
    calculateHeight(grid) {
        for (let y = 0; y < GRID_HEIGHT; y++) {
            for (let x = 0; x < GRID_WIDTH; x++) {
                if (grid[y][x] !== 0) {
                    return GRID_HEIGHT - y;
                }
            }
        }
        return 0;
    }
    
    /**
     * å®Œæˆãƒ©ã‚¤ãƒ³æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
     * @param {Array} grid - ã‚°ãƒªãƒƒãƒ‰
     * @returns {number} å®Œæˆãƒ©ã‚¤ãƒ³æ•°
     */
    countCompletedLines(grid) {
        let count = 0;
        for (let y = 0; y < GRID_HEIGHT; y++) {
            let isComplete = true;
            for (let x = 0; x < GRID_WIDTH; x++) {
                if (grid[y][x] === 0) {
                    isComplete = false;
                    break;
                }
            }
            if (isComplete) count++;
        }
        return count;
    }
    
    /**
     * ç©´ã®æ•°ã‚’ã‚«ã‚¦ãƒ³ãƒˆ
     * @param {Array} grid - ã‚°ãƒªãƒƒãƒ‰
     * @returns {number} ç©´ã®æ•°
     */
    countHoles(grid) {
        let holes = 0;
        
        for (let x = 0; x < GRID_WIDTH; x++) {
            let blockFound = false;
            for (let y = 0; y < GRID_HEIGHT; y++) {
                if (grid[y][x] !== 0) {
                    blockFound = true;
                } else if (blockFound) {
                    holes++;
                }
            }
        }
        
        return holes;
    }
    
    /**
     * è¡¨é¢ã®å‡¹å‡¸åº¦ã‚’è¨ˆç®—
     * @param {Array} grid - ã‚°ãƒªãƒƒãƒ‰
     * @returns {number} å‡¹å‡¸åº¦
     */
    calculateBumpiness(grid) {
        const heights = [];
        
        // å„åˆ—ã®é«˜ã•ã‚’è¨ˆç®—
        for (let x = 0; x < GRID_WIDTH; x++) {
            let height = 0;
            for (let y = 0; y < GRID_HEIGHT; y++) {
                if (grid[y][x] !== 0) {
                    height = GRID_HEIGHT - y;
                    break;
                }
            }
            heights.push(height);
        }
        
        // éš£æ¥ã™ã‚‹åˆ—ã®é«˜ã•å·®ã®åˆè¨ˆ
        let bumpiness = 0;
        for (let i = 0; i < heights.length - 1; i++) {
            bumpiness += Math.abs(heights[i] - heights[i + 1]);
        }
        
        return bumpiness;
    }
    
    /**
     * ãƒ©ãƒ³ãƒ€ãƒ é…ç½®å–å¾—ï¼ˆãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ç”¨ï¼‰
     * @param {Array} grid - ã‚°ãƒªãƒƒãƒ‰
     * @param {Array} shape - ãƒ†ãƒˆãƒªãƒŸãƒå½¢çŠ¶
     * @returns {Object} ãƒ©ãƒ³ãƒ€ãƒ é…ç½®
     */
    getRandomPlacement(grid, shape) {
        const possiblePlacements = [];
        
        for (let x = 0; x <= GRID_WIDTH - shape[0].length; x++) {
            const y = this.findDropPosition(grid, shape, x);
            if (y >= 0) {
                possiblePlacements.push({
                    x: x,
                    y: y,
                    rotation: 0,
                    shape: shape
                });
            }
        }
        
        if (possiblePlacements.length === 0) {
            return null;
        }
        
        const randomIndex = Math.floor(Math.random() * possiblePlacements.length);
        return possiblePlacements[randomIndex];
    }
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã«AIã‚¨ãƒ³ã‚¸ãƒ³ã‚’å…¬é–‹
window.aiEngine = new AIEngine();
```

### 6.3 main.jsï¼ˆå®Œå…¨ç‰ˆï¼‰

```javascript
/**
 * ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ - ãƒªãƒãƒ¼ã‚¹ãƒ†ãƒˆãƒªã‚¹
 * UIã¨ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã®çµ±åˆ
 */

class ReverseTetricsApp {
    constructor() {
        this.gameEngine = null;
        this.isInitialized = false;
        
        this.init();
    }
    
    /**
     * ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³åˆæœŸåŒ–
     */
    init() {
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', () => this.setup());
        } else {
            this.setup();
        }
    }
    
    /**
     * ã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ—
     */
    setup() {
        try {
            // ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³åˆæœŸåŒ–
            this.gameEngine = new GameEngine();
            
            // UIè¦ç´ ã®è¨­å®š
            this.setupPieceSelector();
            this.setupControls();
            this.setupDifficulty();
            this.setupKeyboardEvents();
            
            // åˆæœŸUIæ›´æ–°
            this.gameEngine.updateUI();
            
            this.isInitialized = true;
            console.log('Reverse Tetris initialized successfully');
            
        } catch (error) {
            console.error('Failed to initialize game:', error);
            this.showError('ã‚²ãƒ¼ãƒ ã®åˆæœŸåŒ–ã«å¤±æ•—ã—ã¾ã—ãŸã€‚ãƒšãƒ¼ã‚¸ã‚’å†èª­ã¿è¾¼ã¿ã—ã¦ãã ã•ã„ã€‚');
        }
    }
    
    /**
     * ãƒ”ãƒ¼ã‚¹ã‚»ãƒ¬ã‚¯ã‚¿ãƒ¼ã®è¨­å®š
     */
    setupPieceSelector() {
        const selector = document.getElementById('piece-selector');
        if (!selector) return;
        
        selector.innerHTML = '';
        
        Object.entries(TETROMINOS).forEach(([type, tetromino]) => {
            const btn = document.createElement('button');
            btn.className = 'piece-btn';
            btn.dataset.type = type;
            btn.title = `${type}ãƒ”ãƒ¼ã‚¹`;
            
            // ãƒŸãƒ‹ã‚­ãƒ£ãƒ³ãƒã‚¹ä½œæˆ
            const canvas = document.createElement('canvas');
            canvas.width = 50;
            canvas.height = 50;
            const ctx = canvas.getContext('2d');
            
            // ãƒ”ãƒ¼ã‚¹æç”»
            this.drawMiniPiece(ctx, tetromino.shape, tetromino.color, 50, 50);
            
            btn.appendChild(canvas);
            
            // ã‚¯ãƒªãƒƒã‚¯ã‚¤ãƒ™ãƒ³ãƒˆ
            btn.addEventListener('click', () => {
                if (!this.isInitialized) return;
                
                // ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
                this.showPieceSelection(btn);
                
                // ãƒ”ãƒ¼ã‚¹é¸æŠ
                this.gameEngine.selectPiece(type);
            });
            
            // ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£
            btn.addEventListener('keydown', (e) => {
                if (e.key === 'Enter' || e.key === ' ') {
                    e.preventDefault();
                    btn.click();
                }
            });
            
            selector.appendChild(btn);
        });
    }
    
    /**
     * ãƒ”ãƒ¼ã‚¹é¸æŠæ™‚ã®ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
     */
    showPieceSelection(btn) {
        btn.classList.add('selected');
        btn.classList.add('pulse');
        
        setTimeout(() => {
            btn.classList.remove('selected');
            btn.classList.remove('pulse');
        }, 200);
    }
    
    /**
     * ãƒŸãƒ‹ãƒ”ãƒ¼ã‚¹æç”»
     */
    drawMiniPiece(ctx, shape, color, width, height) {
        ctx.clearRect(0, 0, width, height);
        
        const cellSize = Math.min(
            (width - 10) / shape[0].length,
            (height - 10) / shape.length
        );
        const offsetX = (width - shape[0].length * cellSize) / 2;
        const offsetY = (height - shape.length * cellSize) / 2;
        
        ctx.fillStyle = color;
        
        for (let y = 0; y < shape.length; y++) {
            for (let x = 0; x < shape[y].length; x++) {
                if (shape[y][x]) {
                    // ãƒ¡ã‚¤ãƒ³ãƒ–ãƒ­ãƒƒã‚¯
                    ctx.fillRect(
                        offsetX + x * cellSize,
                        offsetY + y * cellSize,
                        cellSize - 1,
                        cellSize - 1
                    );
                    
                    // ãƒã‚¤ãƒ©ã‚¤ãƒˆåŠ¹æœ
                    ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.fillRect(
                        offsetX + x * cellSize + 1,
                        offsetY + y * cellSize + 1,
                        cellSize - 3,
                        2
                    );
                    ctx.fillStyle = color;
                }
            }
        }
    }
    
    /**
     * ã‚³ãƒ³ãƒˆãƒ­ãƒ¼ãƒ«ãƒœã‚¿ãƒ³ã®è¨­å®š
     */
    setupControls() {
        const startBtn = document.getElementById('start-btn');
        const pauseBtn = document.getElementById('pause-btn');
        const resetBtn = document.getElementById('reset-btn');
        
        if (startBtn) {
            startBtn.addEventListener('click', () => {
                if (!this.isInitialized) return;
                this.gameEngine.start();
                this.hideGameMessage();
                this.showTemporaryMessage('ã‚²ãƒ¼ãƒ é–‹å§‹ï¼');
            });
        }
        
        if (pauseBtn) {
            pauseBtn.addEventListener('click', () => {
                if (!this.isInitialized) return;
                this.gameEngine.togglePause();
                
                const isPaused = this.gameEngine.state.isPaused;
                this.showTemporaryMessage(isPaused ? 'ä¸€æ™‚åœæ­¢ä¸­' : 'ã‚²ãƒ¼ãƒ å†é–‹ï¼');
            });
        }
        
        if (resetBtn) {
            resetBtn.addEventListener('click', () => {
                if (!this.isInitialized) return;
                
                if (confirm('ã‚²ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã™ã‹ï¼Ÿ')) {
                    this.gameEngine.reset();
                    this.hideGameMessage();
                    this.showTemporaryMessage('ã‚²ãƒ¼ãƒ ã‚’ãƒªã‚»ãƒƒãƒˆã—ã¾ã—ãŸ');
                }
            });
        }
    }
    
    /**
     * é›£æ˜“åº¦è¨­å®š
     */
    setupDifficulty() {
        const difficultySelect = document.getElementById('difficulty');
        if (!difficultySelect) return;
        
        difficultySelect.addEventListener('change', (e) => {
            if (!this.isInitialized) return;
            
            const difficulty = e.target.value;
            this.gameEngine.setDifficulty(difficulty);
            
            // ã‚²ãƒ¼ãƒ ä¸­ã®å ´åˆã¯è­¦å‘Š
            if (this.gameEngine.state.isPlaying) {
                this.showTemporaryMessage('é›£æ˜“åº¦å¤‰æ›´ã¯æ¬¡ã®ã‚²ãƒ¼ãƒ ã‹ã‚‰åæ˜ ã•ã‚Œã¾ã™');
            } else {
                this.showTemporaryMessage(`é›£æ˜“åº¦ã‚’ã€Œ${this.getDifficultyName(difficulty)}ã€ã«å¤‰æ›´ã—ã¾ã—ãŸ`);
            }
        });
    }
    
    /**
     * é›£æ˜“åº¦åå–å¾—
     */
    getDifficultyName(difficulty) {
        const names = {
            easy: 'ã‹ã‚“ãŸã‚“',
            normal: 'ãµã¤ã†',
            hard: 'ã‚€ãšã‹ã—ã„'
        };
        return names[difficulty] || difficulty;
    }
    
    /**
     * ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
     */
    setupKeyboardEvents() {
        document.addEventListener('keydown', (e) => {
            if (!this.isInitialized) return;
            
            // æ•°å­—ã‚­ãƒ¼ã§ãƒ”ãƒ¼ã‚¹é¸æŠ
            const pieceKeys = {
                '1': 'I', '2': 'O', '3': 'T', '4': 'S',
                '5': 'Z', '6': 'J', '7': 'L'
            };
            
            if (pieceKeys[e.key]) {
                e.preventDefault();
                this.gameEngine.selectPiece(pieceKeys[e.key]);
                
                // å¯¾å¿œã™ã‚‹ãƒœã‚¿ãƒ³ã‚’ãƒã‚¤ãƒ©ã‚¤ãƒˆ
                const btn = document.querySelector(`[data-type="${pieceKeys[e.key]}"]`);
                if (btn) this.showPieceSelection(btn);
            }
            
            // åˆ¶å¾¡ã‚­ãƒ¼
            switch (e.key) {
                case ' ': // ã‚¹ãƒšãƒ¼ã‚¹ã‚­ãƒ¼ã§ä¸€æ™‚åœæ­¢
                    e.preventDefault();
                    if (this.gameEngine.state.isPlaying) {
                        this.gameEngine.togglePause();
                    }
                    break;
                    
                case 'r': // Rã‚­ãƒ¼ã§ãƒªã‚»ãƒƒãƒˆ
                case 'R':
                    if (e.ctrlKey) {
                        e.preventDefault();
                        document.getElementById('reset-btn')?.click();
                    }
                    break;
                    
                case 'Enter': // Enterã‚­ãƒ¼ã§ã‚²ãƒ¼ãƒ é–‹å§‹
                    if (!this.gameEngine.state.isPlaying) {
                        e.preventDefault();
                        document.getElementById('start-btn')?.click();
                    }
                    break;
            }
        });
    }
    
    /**
     * ã‚²ãƒ¼ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚’éè¡¨ç¤º
     */
    hideGameMessage() {
        const messageEl = document.getElementById('game-message');
        if (messageEl) {
            messageEl.classList.add('hidden');
        }
    }
    
    /**
     * ä¸€æ™‚çš„ãªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è¡¨ç¤º
     */
    showTemporaryMessage(message, duration = 2000) {
        const messageEl = document.getElementById('game-message');
        if (!messageEl) return;
        
        messageEl.innerHTML = `<p class="fade-in">${message}</p>`;
        messageEl.classList.remove('hidden');
        
        setTimeout(() => {
            messageEl.classList.add('hidden');
        }, duration);
    }
    
    /**
     * ã‚¨ãƒ©ãƒ¼è¡¨ç¤º
     */
    showError(message) {
        const messageEl = document.getElementById('game-message');
        if (messageEl) {
            messageEl.innerHTML = `
                <h2 style="color: #dc3545;">ã‚¨ãƒ©ãƒ¼</h2>
                <p>${message}</p>
            `;
            messageEl.classList.remove('hidden');
        } else {
            alert(message);
        }
    }
}

// ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³é–‹å§‹
const app = new ReverseTetricsApp();

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¢ã‚¯ã‚»ã‚¹ç”¨
window.reverseTetricsApp = app;

// ãƒ‡ãƒãƒƒã‚°ç”¨ãƒ˜ãƒ«ãƒ‘ãƒ¼
if (window.location.hostname === 'localhost' || window.location.hostname === '127.0.0.1') {
    window.debugGame = () => {
        console.log('=== Debug Information ===');
        console.log('Game State:', app.gameEngine?.state);
        console.log('Grid:', app.gameEngine?.grid);
        console.log('Score:', app.gameEngine?.score);
        console.log('AI Engine:', window.aiEngine);
        console.log('Current Piece:', app.gameEngine?.currentPiece);
        console.log('Queue:', app.gameEngine?.pieceQueue);
    };
    
    window.simulateGame = (steps = 10) => {
        console.log(`Simulating ${steps} moves...`);
        if (!app.gameEngine?.state.isPlaying) {
            app.gameEngine?.start();
        }
        
        const pieces = Object.keys(TETROMINOS);
        let count = 0;
        
        const interval = setInterval(() => {
            if (count >= steps || app.gameEngine?.state.isGameClear) {
                clearInterval(interval);
                console.log('Simulation completed');
                return;
            }
            
            const randomPiece = pieces[Math.floor(Math.random() * pieces.length)];
            app.gameEngine?.selectPiece(randomPiece);
            count++;
        }, 1000);
    };
    
    console.log('Debug mode enabled. Use debugGame() to inspect or simulateGame(10) to test.');
}
```

---

## 7. ãƒ†ã‚¹ãƒˆãƒ»ãƒ‡ãƒãƒƒã‚°æ‰‹é †

### 7.1 æ®µéšçš„ãƒ†ã‚¹ãƒˆæ‰‹é †

#### ãƒ•ã‚§ãƒ¼ã‚º1: åŸºæœ¬å‹•ä½œãƒ†ã‚¹ãƒˆ
1. **HTMLæ§‹é€ ç¢ºèª**
   ```bash
   # ãƒ­ãƒ¼ã‚«ãƒ«ã‚µãƒ¼ãƒãƒ¼èµ·å‹•
   python -m http.server 8000
   # ã¾ãŸã¯
   npx serve .
   ```

2. **Canvasæç”»ãƒ†ã‚¹ãƒˆ**
   - ã‚°ãƒªãƒƒãƒ‰ç·šãŒæ­£ã—ãè¡¨ç¤ºã•ã‚Œã‚‹ã‹
   - ãƒœãƒ¼ãƒ‰ã‚µã‚¤ã‚ºãŒ300Ã—600pxã‹
   - èƒŒæ™¯è‰²ãŒæ­£ã—ãè¨­å®šã•ã‚Œã¦ã„ã‚‹ã‹

3. **UIè¦ç´ ãƒ†ã‚¹ãƒˆ**
   - å…¨ã¦ã®ãƒœã‚¿ãƒ³ãŒè¡¨ç¤ºã•ã‚Œã‚‹ã‹
   - ãƒ”ãƒ¼ã‚¹é¸æŠãƒœã‚¿ãƒ³ãŒ7ã¤è¡¨ç¤ºã•ã‚Œã‚‹ã‹
   - ã‚¹ã‚³ã‚¢è¡¨ç¤ºã‚¨ãƒªã‚¢ãŒæ©Ÿèƒ½ã™ã‚‹ã‹

#### ãƒ•ã‚§ãƒ¼ã‚º2: ã‚²ãƒ¼ãƒ æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ
1. **ã‚²ãƒ¼ãƒ é–‹å§‹/åœæ­¢**
   ```javascript
   // ãƒ‡ãƒãƒƒã‚°ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§å®Ÿè¡Œ
   debugGame(); // çŠ¶æ…‹ç¢ºèª
   ```

2. **ãƒ”ãƒ¼ã‚¹é¸æŠãƒ»é…ç½®**
   - å„ãƒ”ãƒ¼ã‚¹ãƒœã‚¿ãƒ³ã®ã‚¯ãƒªãƒƒã‚¯å‹•ä½œ
   - ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œï¼ˆ1-7ã‚­ãƒ¼ï¼‰
   - AIé…ç½®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ ã®å‹•ä½œ

3. **ãƒ©ã‚¤ãƒ³æ¶ˆå»ãƒ†ã‚¹ãƒˆ**
   - å®Œæˆãƒ©ã‚¤ãƒ³æ¤œå‡º
   - ãƒã‚¤ãƒ©ã‚¤ãƒˆè¡¨ç¤º
   - å‰Šé™¤ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³

#### ãƒ•ã‚§ãƒ¼ã‚º3: ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢ãƒ»AIå‹•ä½œãƒ†ã‚¹ãƒˆ
1. **ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢åˆ¤å®š**
   ```javascript
   // å¼·åˆ¶çš„ã«ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢çŠ¶æ…‹ã‚’ãƒ†ã‚¹ãƒˆ
   simulateGame(20);
   ```

2. **AIé›£æ˜“åº¦ãƒ†ã‚¹ãƒˆ**
   - Easy: ãƒ©ãƒ³ãƒ€ãƒ æ€§ã®ç¢ºèª
   - Normal: ãƒãƒ©ãƒ³ã‚¹ã®ç¢ºèª
   - Hard: æœ€é©åŒ–ã®ç¢ºèª

### 7.2 ãƒ‡ãƒãƒƒã‚°ãƒ„ãƒ¼ãƒ«

#### é–‹ç™ºè€…ãƒ„ãƒ¼ãƒ«ä½¿ç”¨æ–¹æ³•
```javascript
// ã‚³ãƒ³ã‚½ãƒ¼ãƒ«ã§ã®ãƒ‡ãƒãƒƒã‚°ã‚³ãƒãƒ³ãƒ‰
debugGame();                    // ç¾åœ¨ã®çŠ¶æ…‹ç¢ºèª
simulateGame(10);              // è‡ªå‹•ãƒ†ã‚¹ãƒˆãƒ—ãƒ¬ã‚¤
window.reverseTetricsApp.gameEngine.grid; // ã‚°ãƒªãƒƒãƒ‰çŠ¶æ…‹ç¢ºèª
```

#### ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ³•

1. **ãƒ”ãƒ¼ã‚¹ãŒè¡¨ç¤ºã•ã‚Œãªã„**
   ```javascript
   // Canvasè¦ç´ ã®ç¢ºèª
   console.log(document.getElementById('game-board'));
   // æç”»ã‚³ãƒ³ãƒ†ã‚­ã‚¹ãƒˆã®ç¢ºèª
   console.log(app.gameEngine.ctx);
   ```

2. **ãƒ©ã‚¤ãƒ³æ¶ˆå»ãŒå‹•ä½œã—ãªã„**
   ```javascript
   // ãƒ©ã‚¤ãƒ³æ¤œå‡ºã®ç¢ºèª
   app.gameEngine.checkAndClearLines();
   ```

3. **AIé…ç½®ãŒæ©Ÿèƒ½ã—ãªã„**
   ```javascript
   // AIã‚¨ãƒ³ã‚¸ãƒ³ã®ç¢ºèª
   console.log(window.aiEngine);
   ```

### 7.3 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ãƒ†ã‚¹ãƒˆ

#### ãƒ•ãƒ¬ãƒ¼ãƒ ãƒ¬ãƒ¼ãƒˆç›£è¦–
```javascript
let frameCount = 0;
let lastTime = performance.now();

function measureFPS() {
    frameCount++;
    const currentTime = performance.now();
    
    if (currentTime - lastTime >= 1000) {
        console.log(`FPS: ${frameCount}`);
        frameCount = 0;
        lastTime = currentTime;
    }
    
    requestAnimationFrame(measureFPS);
}

measureFPS();
```

#### ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ç›£è¦–
```javascript
// ãƒ¡ãƒ¢ãƒªä½¿ç”¨é‡ãƒã‚§ãƒƒã‚¯ï¼ˆChromeï¼‰
if (performance.memory) {
    setInterval(() => {
        const memory = performance.memory;
        console.log(`Used: ${(memory.usedJSHeapSize / 1048576).toFixed(2)}MB`);
        console.log(`Total: ${(memory.totalJSHeapSize / 1048576).toFixed(2)}MB`);
    }, 5000);
}
```

---

## 8. ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ

### 8.1 GitHub Pagesè¨­å®š

#### æ‰‹é †
1. **ãƒªãƒã‚¸ãƒˆãƒªæº–å‚™**
   ```bash
   git add .
   git commit -m "Complete Reverse Tetris implementation"
   git push origin main
   ```

2. **GitHub Pagesæœ‰åŠ¹åŒ–**
   - ãƒªãƒã‚¸ãƒˆãƒªè¨­å®šç”»é¢
   - Pages ã‚»ã‚¯ã‚·ãƒ§ãƒ³
   - Source: Deploy from a branch
   - Branch: main / (root)

3. **ã‚«ã‚¹ã‚¿ãƒ ãƒ‰ãƒ¡ã‚¤ãƒ³è¨­å®šï¼ˆã‚ªãƒ—ã‚·ãƒ§ãƒ³ï¼‰**
   ```
   # CNAME ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
   echo "your-domain.com" > CNAME
   ```

### 8.2 ãã®ä»–ã®ãƒ‡ãƒ—ãƒ­ã‚¤ã‚ªãƒ—ã‚·ãƒ§ãƒ³

#### Netlify
```bash
# netlify-cliä½¿ç”¨
npm install -g netlify-cli
netlify deploy --prod --dir .
```

#### Vercel
```bash
# vercel-cliä½¿ç”¨
npm install -g vercel
vercel --prod
```

### 8.3 ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–

#### ç”»åƒæœ€é©åŒ–
- ãƒ”ãƒ¼ã‚¹ã‚¢ã‚¤ã‚³ãƒ³ã‚’SVGã«å¤‰æ›
- Canvasæç”»ã®æœ€é©åŒ–

#### ã‚³ãƒ¼ãƒ‰æœ€é©åŒ–
```javascript
// æœ¬ç•ªç”¨ã®æœ€å°åŒ–è¨­å®š
// ä¸è¦ãªconsole.logã®å‰Šé™¤
// ãƒ‡ãƒãƒƒã‚°æ©Ÿèƒ½ã®ç„¡åŠ¹åŒ–
```

---

## 9. å®Ÿè£…ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

### 9.1 å¿…é ˆæ©Ÿèƒ½ãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

- [ ] **HTMLæ§‹é€ **
  - [ ] æ­£ã—ã„ã‚»ãƒãƒ³ãƒ†ã‚£ãƒƒã‚¯HTML
  - [ ] ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–å¯¾å¿œã®ãƒ¡ã‚¿ã‚¿ã‚°
  - [ ] å¿…è¦ãªå…¨UIè¦ç´ 

- [ ] **CSSè¨­è¨ˆ**
  - [ ] ãƒ•ãƒ¬ãƒƒã‚¯ã‚¹ãƒœãƒƒã‚¯ã‚¹ãƒ¬ã‚¤ã‚¢ã‚¦ãƒˆ
  - [ ] ãƒ¬ã‚¹ãƒãƒ³ã‚·ãƒ–ãƒ‡ã‚¶ã‚¤ãƒ³
  - [ ] ã‚¢ãƒ‹ãƒ¡ãƒ¼ã‚·ãƒ§ãƒ³åŠ¹æœ

- [ ] **JavaScriptåŸºæœ¬æ©Ÿèƒ½**
  - [ ] ã‚²ãƒ¼ãƒ ã‚¨ãƒ³ã‚¸ãƒ³ã‚¯ãƒ©ã‚¹
  - [ ] AIã‚¨ãƒ³ã‚¸ãƒ³ã‚¯ãƒ©ã‚¹
  - [ ] ãƒ¡ã‚¤ãƒ³ã‚¢ãƒ—ãƒªã‚±ãƒ¼ã‚·ãƒ§ãƒ³ã‚¯ãƒ©ã‚¹

- [ ] **ã‚²ãƒ¼ãƒ æ©Ÿèƒ½**
  - [ ] ãƒ”ãƒ¼ã‚¹é¸æŠã‚·ã‚¹ãƒ†ãƒ 
  - [ ] AIé…ç½®ã‚¢ãƒ«ã‚´ãƒªã‚ºãƒ 
  - [ ] ãƒ©ã‚¤ãƒ³æ¶ˆå»å‡¦ç†
  - [ ] ã‚²ãƒ¼ãƒ ã‚¯ãƒªã‚¢åˆ¤å®š

- [ ] **UI/UX**
  - [ ] ãƒ“ã‚¸ãƒ¥ã‚¢ãƒ«ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯
  - [ ] ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰æ“ä½œ
  - [ ] ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£

### 9.2 å“è³ªãƒã‚§ãƒƒã‚¯ãƒªã‚¹ãƒˆ

- [ ] **ã‚³ãƒ¼ãƒ‰å“è³ª**
  - [ ] ESLinté©åˆ
  - [ ] é©åˆ‡ãªã‚³ãƒ¡ãƒ³ãƒˆ
  - [ ] ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

- [ ] **ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹**
  - [ ] 60FPSç¶­æŒ
  - [ ] ãƒ¡ãƒ¢ãƒªãƒªãƒ¼ã‚¯ç„¡ã—
  - [ ] ãƒ¬ã‚¹ãƒãƒ³ã‚¹æ™‚é–“ < 16ms

- [ ] **äº’æ›æ€§**
  - [ ] ãƒ¢ãƒ€ãƒ³ãƒ–ãƒ©ã‚¦ã‚¶å¯¾å¿œ
  - [ ] ãƒ¢ãƒã‚¤ãƒ«å¯¾å¿œ
  - [ ] ã‚¢ã‚¯ã‚»ã‚·ãƒ“ãƒªãƒ†ã‚£å¯¾å¿œ

### 9.3 æœ€çµ‚ç¢ºèªé …ç›®

- [ ] **æ©Ÿèƒ½ãƒ†ã‚¹ãƒˆ**
  - [ ] å…¨é›£æ˜“åº¦ã§ã®ãƒ—ãƒ¬ã‚¤ãƒ†ã‚¹ãƒˆ
  - [ ] å„ãƒ”ãƒ¼ã‚¹ã‚¿ã‚¤ãƒ—ã§ã®ãƒ†ã‚¹ãƒˆ
  - [ ] ã‚¨ãƒƒã‚¸ã‚±ãƒ¼ã‚¹ã®ãƒ†ã‚¹ãƒˆ

- [ ] **ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ¡ãƒ³ãƒˆ**
  - [ ] æœ¬ç•ªç’°å¢ƒã§ã®å‹•ä½œç¢ºèª
  - [ ] HTTPSå¯¾å¿œ
  - [ ] ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹è¨ˆæ¸¬

---

## 10. ãƒˆãƒ©ãƒ–ãƒ«ã‚·ãƒ¥ãƒ¼ãƒ†ã‚£ãƒ³ã‚°

### 10.1 ã‚ˆãã‚ã‚‹å•é¡Œã¨è§£æ±ºæ³•

#### å•é¡Œ1: CanvasãŒè¡¨ç¤ºã•ã‚Œãªã„
**åŸå› **: HTMLè¦ç´ ã®å–å¾—ã«å¤±æ•—
**è§£æ±ºæ³•**:
```javascript
// DOMèª­ã¿è¾¼ã¿å®Œäº†ç¢ºèª
if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', initGame);
} else {
    initGame();
}
```

#### å•é¡Œ2: ãƒ”ãƒ¼ã‚¹ãŒæ­£ã—ãæç”»ã•ã‚Œãªã„
**åŸå› **: åº§æ¨™è¨ˆç®—ã‚¨ãƒ©ãƒ¼
**è§£æ±ºæ³•**:
```javascript
// å¢ƒç•Œãƒã‚§ãƒƒã‚¯å¼·åŒ–
if (boardX >= 0 && boardX < GRID_WIDTH && 
    boardY >= 0 && boardY < GRID_HEIGHT) {
    // æç”»å‡¦ç†
}
```

#### å•é¡Œ3: ãƒ©ã‚¤ãƒ³æ¶ˆå»ãŒå‹•ä½œã—ãªã„
**åŸå› **: é…åˆ—æ“ä½œã®å•é¡Œ
**è§£æ±ºæ³•**:
```javascript
// ä¸‹ã‹ã‚‰ä¸Šã«å‘ã‹ã£ã¦å‰Šé™¤
const sortedLines = lines.sort((a, b) => b - a);
for (const line of sortedLines) {
    grid.splice(line, 1);
    grid.unshift(Array(GRID_WIDTH).fill(0));
}
```

### 10.2 ãƒ‡ãƒãƒƒã‚°æ–¹æ³•

#### ã‚¹ãƒ†ãƒƒãƒ—ãƒã‚¤ã‚¹ãƒ†ãƒƒãƒ—ãƒ‡ãƒãƒƒã‚°
```javascript
// 1. çŠ¶æ…‹ç¢ºèª
console.log('Game State:', gameEngine.state);

// 2. ã‚°ãƒªãƒƒãƒ‰çŠ¶æ…‹ç¢ºèª
console.log('Grid:', gameEngine.grid);

// 3. ã‚¤ãƒ™ãƒ³ãƒˆç¢ºèª
element.addEventListener('click', (e) => {
    console.log('Click event:', e);
});
```

---

## 11. ã¾ã¨ã‚

ã“ã®å®Œå…¨å®Ÿè£…ä»•æ§˜æ›¸ã«ã‚ˆã‚Šã€ãƒªãƒãƒ¼ã‚¹ãƒ†ãƒˆãƒªã‚¹ã‚’0ã‹ã‚‰å®Ÿè£…ã™ã‚‹ã“ã¨ãŒå¯èƒ½ã§ã™ã€‚

### å®Ÿè£…ã®ãƒã‚¤ãƒ³ãƒˆ
1. **æ®µéšçš„é–‹ç™º**: åŸºæœ¬æ©Ÿèƒ½ã‹ã‚‰é †æ¬¡å®Ÿè£…
2. **ãƒ†ã‚¹ãƒˆé§†å‹•**: å„æ®µéšã§ã®å‹•ä½œç¢ºèª
3. **ã‚³ãƒ¼ãƒ‰å“è³ª**: å¯èª­æ€§ã¨ä¿å®ˆæ€§ã‚’é‡è¦–
4. **ãƒ¦ãƒ¼ã‚¶ãƒ¼ä½“é¨“**: ç›´æ„Ÿçš„ã§æ¥½ã—ã„æ“ä½œæ„Ÿ

### æ¬¡ã®ã‚¹ãƒ†ãƒƒãƒ—
1. åŸºæœ¬å®Ÿè£…ã®å®Œæˆ
2. è¿½åŠ æ©Ÿèƒ½ã®æ¤œè¨
3. ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹æœ€é©åŒ–
4. ã‚³ãƒŸãƒ¥ãƒ‹ãƒ†ã‚£ãƒ•ã‚£ãƒ¼ãƒ‰ãƒãƒƒã‚¯

ã“ã®ä»•æ§˜æ›¸ã«å¾“ã£ã¦å®Ÿè£…ã™ã‚‹ã“ã¨ã§ã€å®Œå…¨ã«å‹•ä½œã™ã‚‹ãƒªãƒãƒ¼ã‚¹ãƒ†ãƒˆãƒªã‚¹ã‚²ãƒ¼ãƒ ãŒå®Œæˆã—ã¾ã™ã€‚

---

**ãƒãƒ¼ã‚¸ãƒ§ãƒ³**: 3.0.0  
**æ›´æ–°æ—¥**: 2024-08-15  
**ä½œæˆè€…**: Claude Code Assistant